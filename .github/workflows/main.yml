name: RenoPilot Web App CI/CD

on: 
  push:
    branches: [main]
    paths-ignore:
    - '.github/workflows/container-instance-ci-cd.yaml'
  pull_request:
    branches: [main]
    paths-ignore:
    - '.github/workflows/container-instance-ci-cd.yaml'
  workflow_dispatch:

jobs:
  test-app:
    runs-on: ubuntu-latest
    name: Test R Shiny App
    env:
      GITHUB_PAT: ${{ secrets.RENOPILOT_TOKEN }}
      R_KEEP_PKG_SOURCE: yes

    steps:
      - name: Checkout Code Base
        uses: actions/checkout@v3

      - name: Set up R Environment
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: release
          use-public-rspm: true

      - name: Install Dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: shinytest2

      - name: Define Environment Variables
        run: |
          echo Environment="Github" >> ~/.Renviron
          echo Driver="ODBC Driver 18 for SQL Server" >> ~/.Renviron
          echo Server="shiny.database.windows.net" >> ~/.Renviron
          echo Database="Shiny" >> ~/.Renviron
          echo UID="shiny" >> ~/.Renviron
          echo PWD="${{ secrets.DB_PASSWORD }}" >> ~/.Renviron
        shell: bash

      - name: Run Tests
        uses: rstudio/shinytest2/actions/test-app@v1
        with:
          path: "."

  deploy-infrastructure:
    needs: test-app
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@main

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Register Required Resource Providers
      uses: azure/cli@v1
      with:
        inlineScript: |
          echo "Registering Azure resource providers required for RenoPilot Web App infrastructure..."
          # These Microsoft namespaces are required Azure services for RenoPilot application
          # They cannot be renamed but are essential for our infrastructure
          az provider register --namespace Microsoft.Web
          az provider register --namespace Microsoft.ContainerRegistry
          az provider register --namespace Microsoft.Network
          
          echo "Waiting for RenoPilot required Azure service registrations to complete..."
          # Checking registration status for required providers
          az provider show -n Microsoft.Web --query registrationState
          az provider show -n Microsoft.ContainerRegistry --query registrationState
          az provider show -n Microsoft.Network --query registrationState
          
          # Verify registrations with timeout
          for provider in Microsoft.Web Microsoft.ContainerRegistry Microsoft.Network; do
            state=$(az provider show -n $provider --query registrationState -o tsv)
            echo "RenoPilot Azure dependency: $provider registration state: $state"
            if [ "$state" != "Registered" ]; then
              echo "Waiting for $provider to complete registration..."
              for i in {1..12}; do
                sleep 10
                state=$(az provider show -n $provider --query registrationState -o tsv)
                echo "$provider registration state: $state"
                if [ "$state" == "Registered" ]; then
                  break
                fi
                if [ $i -eq 12 ] && [ "$state" != "Registered" ]; then
                  echo "Warning: $provider registration taking longer than expected. Continuing anyway."
                fi
              done
            fi
          done

    - name: Clean Up Existing Infrastructure
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Check if Resource Group exists
          RG_EXISTS=$(az group exists --name RenoPilotWebAppRG)
          
          if [ "$RG_EXISTS" = "true" ]; then
            echo "Resource Group exists. Beginning cleanup of existing resources..."
            
            # 0. First do a specific cleanup of ACR to ensure it's properly removed
            echo "Looking for all ACRs with renopilot prefix..."
            ACR_LIST=$(az acr list --query "[?starts_with(name, 'renopilot')].name" -o tsv)
            
            if [ -n "$ACR_LIST" ]; then
              for ACR in $ACR_LIST; do
                echo "Found ACR: $ACR. Checking if it belongs to our RG..."
                ACR_RG=$(az acr show --name $ACR --query resourceGroup -o tsv 2>/dev/null || echo "unknown")
                
                if [ "$ACR_RG" == "RenoPilotWebAppRG" ] || [ "$ACR_RG" == "unknown" ]; then
                  echo "Attempting to delete ACR: $ACR"
                  # Try multiple times with increased timeouts
                  for i in {1..3}; do
                    if az acr delete --name $ACR --resource-group RenoPilotWebAppRG --yes --output none 2>/dev/null; then
                      echo "Successfully deleted ACR: $ACR"
                      break
                    else
                      echo "Failed to delete ACR on attempt $i, waiting and retrying..."
                      sleep 30
                    fi
                    
                    if [ $i -eq 3 ]; then
                      echo "Warning: Could not delete ACR: $ACR after multiple attempts. Continuing with other resources."
                    fi
                  done
                fi
              done
              
              # Wait for ACR deletions to complete
              echo "Waiting for ACR deletions to propagate..."
              sleep 60
            else
              echo "No ACRs with renopilot prefix found."
            fi
            
            # 1. Clean up Web Apps
            echo "Cleaning up Web Apps..."
            WEBAPPS=$(az webapp list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$WEBAPPS" ]; then
              for WEBAPP in $WEBAPPS; do
                echo "Deleting Web App: $WEBAPP"
                az webapp delete --name $WEBAPP --resource-group RenoPilotWebAppRG --keep-empty-plan
              done
              # Wait for webapp deletion to complete
              sleep 30
            else
              echo "No Web Apps found to clean up."
            fi
            
            # 2. Clean up App Service Plans
            echo "Cleaning up App Service Plans..."
            APP_PLANS=$(az appservice plan list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$APP_PLANS" ]; then
              for PLAN in $APP_PLANS; do
                echo "Deleting App Service Plan: $PLAN"
                az appservice plan delete --name $PLAN --resource-group RenoPilotWebAppRG --yes
              done
              # Wait for app plan deletion to complete
              sleep 30
            else
              echo "No App Service Plans found to clean up."
            fi
            
            # 3. First remove NSG associations from subnets - FIX ERROR HERE
            echo "Removing NSG associations from subnets..."
            VNETS=$(az network vnet list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$VNETS" ]; then
              for VNET in $VNETS; do
                SUBNETS=$(az network vnet subnet list --resource-group RenoPilotWebAppRG --vnet-name $VNET --query "[].name" -o tsv)
                for SUBNET in $SUBNETS; do
                  echo "Removing NSG association from subnet: $SUBNET in VNet: $VNET"
                  # Check for existing NSG association first
                  NSG_ID=$(az network vnet subnet show --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --query "networkSecurityGroup.id" -o tsv 2>/dev/null || echo "")
                  RT_ID=$(az network vnet subnet show --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --query "routeTable.id" -o tsv 2>/dev/null || echo "")
                  
                  # Remove NSG association if it exists
                  if [ -n "$NSG_ID" ] && [ "$NSG_ID" != "null" ]; then
                    echo "Removing NSG association from subnet $SUBNET"
                    az network vnet subnet update --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --remove networkSecurityGroup || echo "Failed to remove NSG from subnet $SUBNET, continuing..."
                  else
                    echo "No NSG association found for subnet $SUBNET"
                  fi
                  
                  # Remove route table association if it exists
                  if [ -n "$RT_ID" ] && [ "$RT_ID" != "null" ]; then
                    echo "Removing route table association from subnet $SUBNET"
                    az network vnet subnet update --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --remove routeTable || echo "Failed to remove route table from subnet $SUBNET, continuing..."
                  else
                    echo "No route table association found for subnet $SUBNET"
                  fi
                done
              done
              # Wait for association removal to complete
              sleep 15
            fi
            
            # 4. Now clean up Network Security Groups
            echo "Cleaning up Network Security Groups..."
            NSGS=$(az network nsg list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$NSGS" ]; then
              for NSG in $NSGS; do
                echo "Deleting NSG: $NSG"
                az network nsg delete --name $NSG --resource-group RenoPilotWebAppRG
              done
              # Wait for NSG deletion to complete
              sleep 15
            else
              echo "No NSGs found to clean up."
            fi
            
            # 5. Clean up Firewalls
            echo "Cleaning up Firewalls..."
            FIREWALLS=$(az network firewall list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$FIREWALLS" ]; then
              for FIREWALL in $FIREWALLS; do
                echo "Deleting Firewall: $FIREWALL"
                az network firewall delete --name $FIREWALL --resource-group RenoPilotWebAppRG
              done
              # Wait for firewall deletion to complete
              sleep 30
            else
              echo "No Firewalls found to clean up."
            fi
            
            # 6. Clean up Subnets (required before VNet cleanup)
            echo "Cleaning up VNets and Subnets..."
            VNETS=$(az network vnet list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$VNETS" ]; then
              for VNET in $VNETS; do
                # Get subnets in this VNet
                SUBNETS=$(az network vnet subnet list --resource-group RenoPilotWebAppRG --vnet-name $VNET --query "[].name" -o tsv)
                for SUBNET in $SUBNETS; do
                  echo "Deleting Subnet: $SUBNET in VNet: $VNET"
                  az network vnet subnet delete --name $SUBNET --vnet-name $VNET --resource-group RenoPilotWebAppRG
                done
                # Delete VNet after subnets
                echo "Deleting VNet: $VNET"
                az network vnet delete --name $VNET --resource-group RenoPilotWebAppRG
              done
              # Wait for VNet deletion to complete
              sleep 30
            else
              echo "No VNets found to clean up."
            fi
            
            echo "Clean-up completed."
          else
            echo "Resource Group does not exist. No cleanup needed."
          fi

          # Set Australian and Asian regions to use
          REGIONS=("australiaeast" "australiasoutheast" "australiacentral" "australiacentral2" "eastasia" "southeastasia")
          echo "Will create resources in Australian or Asian regions: ${REGIONS[*]}"
    
    - name: Check Existing Infrastructure
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Try a list of regions in order of preference - Australian and Asian regions
          REGIONS=("australiaeast" "australiasoutheast" "eastasia" "southeastasia" "australiacentral" "australiacentral2")
          
          # Default to australiaeast as our anchor region
          LOCATION="australiaeast"
          
          # Check if Resource Group exists
          RG_EXISTS=$(az group exists --name RenoPilotWebAppRG)
          
          if [ "$RG_EXISTS" = "true" ]; then
            echo "Resource Group already exists."
            
            # If resource group exists, check if we already have resources deployed
            # Try to find an existing App Service Plan in the resource group
            EXISTING_PLANS=$(az appservice plan list --resource-group RenoPilotWebAppRG --query "[].{name:name, location:location}" -o json)
            
            # If we have an existing plan, use its location
            if [ -n "$EXISTING_PLANS" ] && [ "$EXISTING_PLANS" != "[]" ]; then
              # Use the location of the first plan found
              LOCATION=$(echo $EXISTING_PLANS | jq -r '.[0].location')
              echo "Using existing resources in location: $LOCATION"
              
              # Try to determine the SKU from existing plan
              EXISTING_SKU=$(az appservice plan show --name $(echo $EXISTING_PLANS | jq -r '.[0].name') --resource-group RenoPilotWebAppRG --query sku.name -o tsv)
              if [ -n "$EXISTING_SKU" ]; then
                echo "Using existing SKU: $EXISTING_SKU"
                echo "APP_SKU=$EXISTING_SKU" >> $GITHUB_ENV
              else
                echo "Using default SKU: B1"
                echo "APP_SKU=B1" >> $GITHUB_ENV
              fi
            else
              echo "Resource Group exists but no App Service Plans found."
              echo "Using default location: $LOCATION and SKU: B1"
              echo "APP_SKU=B1" >> $GITHUB_ENV
              
              # We'll avoid quota checks to prevent throttling
              echo "Skipping quota checks due to previous API throttling. Using default values."
            fi
          else
            echo "Resource Group does not exist. Creating in default location $LOCATION..."
            az group create --name RenoPilotWebAppRG --location $LOCATION
            echo "APP_SKU=B1" >> $GITHUB_ENV
          fi
          
          echo "Final selected location: $LOCATION"
          
          # Store location for use in later steps
          echo "AZURE_LOCATION=$LOCATION" >> $GITHUB_ENV
          
          # Generate a timestamp for unique resource names
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV

    - name: Create VPC and Subnets
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          
          # Create VNet with region-specific name
          VNET_NAME="renopilot-vpc-$LOCATION"
          
          # Check if VNet already exists
          if az network vnet show --name $VNET_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "VNet '$VNET_NAME' already exists. Skipping creation."
          else
            echo "Creating VNet '$VNET_NAME'..."
            
            # Implement retry logic with exponential backoff
            MAX_RETRIES=3
            RETRY_DELAY=30
            SUCCESS=false
            
            for ((i=1; i<=MAX_RETRIES; i++)); do
              echo "Attempt $i of $MAX_RETRIES to create VNet..."
              if ERROR_OUTPUT=$(az network vnet create \
                --name $VNET_NAME \
                --resource-group RenoPilotWebAppRG \
                --location $LOCATION \
                --address-prefix 10.1.0.0/16 2>&1); then
                
                echo "VNet created successfully!"
                SUCCESS=true
                break
              else
                echo "Failed to create VNet on attempt $i"
                echo "Error details:"
                echo "$ERROR_OUTPUT"
                
                # Handle throttling specifically
                if [[ "$ERROR_OUTPUT" == *"throttled"* ]]; then
                  RETRY_DELAY=$((RETRY_DELAY * 2))
                  echo "Throttling detected. Waiting $RETRY_DELAY seconds before retry..."
                fi
                
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "Waiting for $RETRY_DELAY seconds before next attempt..."
                  sleep $RETRY_DELAY
                fi
              fi
            done
            
            if [ "$SUCCESS" != "true" ]; then
              echo "ERROR: Failed to create VNet after $MAX_RETRIES attempts."
              echo "Will attempt to continue the deployment with other resources."
            fi
          fi
          
          # Store VNet name for later steps
          echo "VNET_NAME=$VNET_NAME" >> $GITHUB_ENV
          
          # Public subnet with region-specific name
          PUBLIC_SUBNET_NAME="WebAppPublicSubnet-$LOCATION"
          
          # Check if public subnet already exists
          if az network vnet subnet show --name $PUBLIC_SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Public Subnet '$PUBLIC_SUBNET_NAME' already exists. Skipping creation."
          else
            echo "Creating Public Subnet '$PUBLIC_SUBNET_NAME'..."
            az network vnet subnet create \
              --name $PUBLIC_SUBNET_NAME \
              --vnet-name $VNET_NAME \
              --resource-group RenoPilotWebAppRG \
              --address-prefix 10.1.1.0/24 \
              --delegations Microsoft.Web/serverFarms \
              --service-endpoints Microsoft.Web
            
            # Add delay to ensure subnet is fully provisioned
            sleep 10
          fi
          
          # Store subnet name for later steps
          echo "PUBLIC_SUBNET_NAME=$PUBLIC_SUBNET_NAME" >> $GITHUB_ENV
          
          # Private subnet with region-specific name
          PRIVATE_SUBNET_NAME="WebAppPrivateSubnet-$LOCATION"
          
          # Check if private subnet already exists
          if az network vnet subnet show --name $PRIVATE_SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Private Subnet '$PRIVATE_SUBNET_NAME' already exists. Skipping creation."
          else
            echo "Creating Private Subnet '$PRIVATE_SUBNET_NAME'..."
            az network vnet subnet create \
              --name $PRIVATE_SUBNET_NAME \
              --vnet-name $VNET_NAME \
              --resource-group RenoPilotWebAppRG \
              --address-prefix 10.1.2.0/24
            
            # Add delay to ensure subnet is fully provisioned
            sleep 10
          fi
          
          # Store subnet name for later steps
          echo "PRIVATE_SUBNET_NAME=$PRIVATE_SUBNET_NAME" >> $GITHUB_ENV

    - name: Deploy Network Security Groups
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          # Create NSG with region-specific name
          NSG_NAME="webapp-nsg-$LOCATION"
          
          # Check if NSG already exists
          if az network nsg show --name $NSG_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Network Security Group '$NSG_NAME' already exists. Skipping creation."
          else
            echo "Creating Network Security Group '$NSG_NAME'..."
            az network nsg create \
              --name $NSG_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
            
            # Add explicit inbound rule for Shiny Server port 3838
            echo "Adding inbound security rule for Shiny port 3838..."
            az network nsg rule create \
              --name AllowShinyInbound \
              --nsg-name $NSG_NAME \
              --resource-group RenoPilotWebAppRG \
              --priority 100 \
              --direction Inbound \
              --access Allow \
              --protocol Tcp \
              --source-address-prefixes "*" \
              --source-port-ranges "*" \
              --destination-address-prefixes "*" \
              --destination-port-ranges 3838 \
              --description "Allow Shiny Server traffic on port 3838"
            
            # Add HTTP/HTTPS inbound rules for web traffic
            echo "Adding inbound security rule for HTTP/HTTPS..."
            az network nsg rule create \
              --name AllowHTTPInbound \
              --nsg-name $NSG_NAME \
              --resource-group RenoPilotWebAppRG \
              --priority 200 \
              --direction Inbound \
              --access Allow \
              --protocol Tcp \
              --source-address-prefixes "*" \
              --source-port-ranges "*" \
              --destination-address-prefixes "*" \
              --destination-port-ranges 80 443 \
              --description "Allow HTTP/HTTPS traffic"
          fi
          
          # Store NSG name for later steps
          echo "NSG_NAME=$NSG_NAME" >> $GITHUB_ENV
          
          # Apply NSG to the subnet
          echo "Applying NSG to subnet..."
          az network vnet subnet update \
            --name ${{ env.PUBLIC_SUBNET_NAME }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --resource-group RenoPilotWebAppRG \
            --network-security-group $NSG_NAME

    - name: Deploy Firewalls
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          echo "Creating Firewalls..."
          
          # Create Public Firewall with region-specific name
          PUBLIC_FW_NAME="webapp-publicfw-$LOCATION"
          
          # Check if public firewall already exists
          if az network firewall show --name $PUBLIC_FW_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Public Firewall '$PUBLIC_FW_NAME' already exists. Skipping creation."
          else
            echo "Creating Public Firewall '$PUBLIC_FW_NAME'..."
            az network firewall create \
              --name $PUBLIC_FW_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
          fi
          
          # Store firewall name for later steps
          echo "PUBLIC_FW_NAME=$PUBLIC_FW_NAME" >> $GITHUB_ENV
          
          # Create Private Firewall with region-specific name
          PRIVATE_FW_NAME="webapp-privatefw-$LOCATION"
          
          # Check if private firewall already exists
          if az network firewall show --name $PRIVATE_FW_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Private Firewall '$PRIVATE_FW_NAME' already exists. Skipping creation."
          else
            echo "Creating Private Firewall '$PRIVATE_FW_NAME'..."
            az network firewall create \
              --name $PRIVATE_FW_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
          fi
          
          # Store firewall name for later steps
          echo "PRIVATE_FW_NAME=$PRIVATE_FW_NAME" >> $GITHUB_ENV
          
          # Create a route table for the subnet with region-specific name
          ROUTE_TABLE_NAME="webapp-routes-$LOCATION"
          
          # Check if route table already exists
          if az network route-table show --name $ROUTE_TABLE_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Route Table '$ROUTE_TABLE_NAME' already exists. Skipping creation."
          else
            echo "Creating route table '$ROUTE_TABLE_NAME'..."
            az network route-table create \
              --name $ROUTE_TABLE_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
          fi
          
          # Store route table name for later steps
          echo "ROUTE_TABLE_NAME=$ROUTE_TABLE_NAME" >> $GITHUB_ENV
          
          # Add the route table to the subnet
          echo "Applying route table to subnet..."
          az network vnet subnet update \
            --name ${{ env.PUBLIC_SUBNET_NAME }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --resource-group RenoPilotWebAppRG \
            --route-table $ROUTE_TABLE_NAME

    - name: Deploy Container Registry
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          TIMESTAMP="${{ env.TIMESTAMP }}"
          RUNID="${{ github.run_id }}"
          
          # Use a more unique ACR name that includes run ID to avoid conflicts
          # ACR names must be between 5-50 characters, lowercase alphanumeric
          # First try with location and run ID
          ACR_BASE_NAME="renopilot"
          ACR_NAME="${ACR_BASE_NAME}${LOCATION}${RUNID}"
          
          # Ensure the name is not too long (maximum 50 chars)
          if [ ${#ACR_NAME} -gt 50 ]; then
            # Truncate to fit the 50 character limit
            ACR_NAME="${ACR_BASE_NAME}${RUNID}"
            
            # If still too long, use just timestamp (should be ~14 chars)
            if [ ${#ACR_NAME} -gt 50 ]; then
              ACR_NAME="${ACR_BASE_NAME}${TIMESTAMP}"
            fi
          fi
          
          # Convert to lowercase as ACR names must be lowercase
          ACR_NAME=$(echo "$ACR_NAME" | tr '[:upper:]' '[:lower:]')
          
          echo "Using ACR name: $ACR_NAME"
          
          # Check if name is already in use globally in Azure
          NAME_CHECK=$(az acr check-name --name "$ACR_NAME" --query nameAvailable -o tsv)
          
          # If name isn't available, try adding random suffix
          if [ "$NAME_CHECK" != "true" ]; then
            echo "ACR name $ACR_NAME is already taken. Generating alternative name..."
            RANDOM_SUFFIX=$(head /dev/urandom | tr -dc a-z0-9 | head -c 8)
            ACR_NAME="${ACR_BASE_NAME}${RANDOM_SUFFIX}"
            echo "Generated alternative ACR name: $ACR_NAME"
            
            # Double check the new name
            NAME_CHECK=$(az acr check-name --name "$ACR_NAME" --query nameAvailable -o tsv)
            if [ "$NAME_CHECK" != "true" ]; then
              echo "Error: Still cannot find an available ACR name. Please check Azure portal."
              exit 1
            fi
          fi
          
          # Create the registry with validated name
          echo "Creating Container Registry '$ACR_NAME'..."
          
          # Use retry logic for ACR creation
          MAX_RETRIES=3
          SUCCESS=false
          
          for ((i=1; i<=MAX_RETRIES; i++)); do
            echo "Attempt $i of $MAX_RETRIES to create ACR..."
            if az acr create \
              --resource-group RenoPilotWebAppRG \
              --name $ACR_NAME \
              --sku Standard \
              --location $LOCATION \
              --admin-enabled true; then
              
              echo "ACR created successfully!"
              SUCCESS=true
              break
            else
              echo "Failed to create ACR on attempt $i."
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting before retry..."
                sleep 60
              fi
            fi
          done
          
          if [ "$SUCCESS" != "true" ]; then
            echo "ERROR: Failed to create ACR after $MAX_RETRIES attempts."
            exit 1
          fi
          
          # Retrieve and store registry credentials securely in GitHub environment
          ACR_LOGIN_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)
          ACR_USERNAME=$(az acr credential show -n $ACR_NAME --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show -n $ACR_NAME --query "passwords[0].value" -o tsv)
          
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
          echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV
          # Add mask to hide sensitive output in logs
          echo "::add-mask::$ACR_PASSWORD"

    - name: Check if Docker image exists
      id: check-image
      uses: azure/cli@v1
      with:
        inlineScript: |
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_NAME="renopilot-fenceapp"
          
          # Check if ACR exists before trying to query it
          if ! az acr show --name ${{ env.ACR_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "ACR ${{ env.ACR_NAME }} does not exist. Setting IMAGE_EXISTS=false"
            echo "IMAGE_EXISTS=false" >> $GITHUB_ENV
            echo "exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if the image with the specific tag already exists in ACR
          echo "Checking if image $IMAGE_NAME:$IMAGE_TAG already exists in ACR..."
          
          # Using az acr repository show to check if image exists
          if az acr repository show --name ${{ env.ACR_NAME }} --image "$IMAGE_NAME:$IMAGE_TAG" &>/dev/null; then
            echo "Image $IMAGE_NAME:$IMAGE_TAG already exists in ACR. Skipping build and push."
            echo "IMAGE_EXISTS=true" >> $GITHUB_ENV
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image $IMAGE_NAME:$IMAGE_TAG does not exist in ACR. Will build and push."
            echo "IMAGE_EXISTS=false" >> $GITHUB_ENV
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

    - name: Build and push image
      if: env.IMAGE_EXISTS != 'true'
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ env.ACR_USERNAME }}
        password: ${{ env.ACR_PASSWORD }}
    - run: |
        if [ "${{ env.IMAGE_EXISTS }}" != "true" ]; then
          echo "Building and pushing new Docker image..."
          docker build -f containerResources/dockerfile . -t ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }}          
          docker push ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }}
        else
          echo "Skipping Docker build and push as image already exists."
        fi

    - name: Create App Service Plan
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Create App Service Plan with region-specific name
          LOCATION="${{ env.AZURE_LOCATION }}"
          APP_PLAN_NAME="renopilot-plan-$LOCATION"
          # Use the SKU we set (defaulting to B1)
          SKU="${{ env.APP_SKU }}"
          
          # First check if ANY App Service Plan exists across regions to reuse
          echo "Checking for any existing App Service Plans across regions..."
          EXISTING_PLANS=$(az appservice plan list --query "[?resourceGroup=='RenoPilotWebAppRG'].{name:name, location:location, sku:sku.name}" -o json)
          
          if [ -n "$EXISTING_PLANS" ] && [ "$EXISTING_PLANS" != "[]" ]; then
            # Found existing plans - use the first one regardless of region
            EXISTING_PLAN_NAME=$(echo $EXISTING_PLANS | jq -r '.[0].name')
            EXISTING_PLAN_LOCATION=$(echo $EXISTING_PLANS | jq -r '.[0].location')
            EXISTING_PLAN_SKU=$(echo $EXISTING_PLANS | jq -r '.[0].sku')
            
            echo "Found existing App Service Plan '$EXISTING_PLAN_NAME' in $EXISTING_PLAN_LOCATION with SKU $EXISTING_PLAN_SKU"
            echo "Using existing App Service Plan to avoid throttling..."
            
            # Update location if needed - this might affect other resources but prevents throttling
            if [ "$EXISTING_PLAN_LOCATION" != "$LOCATION" ]; then
              echo "WARNING: Using App Service Plan from a different region ($EXISTING_PLAN_LOCATION) than requested ($LOCATION)"
              echo "This may affect performance but will avoid throttling issues."
              LOCATION=$EXISTING_PLAN_LOCATION
              echo "AZURE_LOCATION=$LOCATION" >> $GITHUB_ENV
            fi
            
            # Store the plan name for later steps
            APP_PLAN_NAME=$EXISTING_PLAN_NAME
            echo "APP_PLAN_NAME=$APP_PLAN_NAME" >> $GITHUB_ENV
            echo "APP_SKU=$EXISTING_PLAN_SKU" >> $GITHUB_ENV
          else
            # Check if App Service Plan already exists in the requested location
            if az appservice plan show --name $APP_PLAN_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
              echo "App Service Plan '$APP_PLAN_NAME' already exists. Skipping creation."
            else
              echo "Creating App Service Plan '$APP_PLAN_NAME' with SKU $SKU..."
              
              # Implement more aggressive exponential backoff for throttling
              MAX_RETRIES=6  # Increased from 5 to 6
              RETRY_DELAY=60  # Start with 1 minute delay
              MAX_DELAY=600  # Max delay of 10 minutes
              SUCCESS=false
              
              for ((attempt=1; attempt<=MAX_RETRIES; attempt++)); do
                echo "Attempt $attempt of $MAX_RETRIES to create App Service Plan..."
                
                # Capture detailed error output
                if ERROR_OUTPUT=$(az appservice plan create \
                  --name $APP_PLAN_NAME \
                  --resource-group RenoPilotWebAppRG \
                  --is-linux \
                  --sku $SKU \
                  --location $LOCATION 2>&1); then
                  
                  echo "App Service Plan created successfully with SKU $SKU!"
                  SUCCESS=true
                  break
                else
                  echo "Failed to create App Service Plan with SKU $SKU."
                  echo "Error details:"
                  echo "$ERROR_OUTPUT"
                  
                  if [[ "$ERROR_OUTPUT" == *"throttled"* ]]; then
                    echo "Detected API throttling."
                    # First attempt alternative SKUs immediately instead of waiting
                    if [ $attempt -eq 1 ]; then
                      echo "Trying with alternative SKUs due to throttling..."
                      for ALT_SKU in "F1" "B2" "S1" "P1v2"; do
                        if [ "$ALT_SKU" != "$SKU" ]; then
                          echo "Attempting with alternative SKU: $ALT_SKU"
                          if az appservice plan create \
                            --name $APP_PLAN_NAME \
                            --resource-group RenoPilotWebAppRG \
                            --is-linux \
                            --sku $ALT_SKU \
                            --location $LOCATION &>/dev/null; then
                            
                            echo "Success with alternative SKU $ALT_SKU!"
                            SKU=$ALT_SKU
                            SUCCESS=true
                            break
                          else
                            echo "Failed with SKU $ALT_SKU, trying next option."
                          fi
                        fi
                      done
                      
                      if [ "$SUCCESS" = "true" ]; then
                        # We succeeded with an alternative SKU
                        break
                      fi
                    fi
                    
                    # Calculate exponential backoff delay with max cap
                    RETRY_DELAY=$((RETRY_DELAY * 2))
                    if [ $RETRY_DELAY -gt $MAX_DELAY ]; then
                      RETRY_DELAY=$MAX_DELAY
                    fi
                    echo "Throttling detected. Using exponential backoff. Waiting $RETRY_DELAY seconds before retry..."
                  else
                    # For non-throttling errors, use standard delay
                    RETRY_DELAY=30
                    echo "Error occurred. Waiting $RETRY_DELAY seconds before retry..."
                  fi
                  
                  if [ $attempt -lt $MAX_RETRIES ]; then
                    sleep $RETRY_DELAY
                  fi
                fi
              done
              
              # If creation still failed after all retries
              if [ "$SUCCESS" = "false" ]; then
                echo "WARNING: Failed to create App Service Plan after $MAX_RETRIES attempts."
                echo "Checking for ANY existing App Service Plan in the subscription to reuse..."
                
                # Desperate measures: look for ANY unused App Service Plan in the subscription
                ALL_PLANS=$(az appservice plan list --query "[?sku.name=='$SKU']|[?numberOfSites==\`0\`].{name:name, location:location}" -o json)
                
                if [ -n "$ALL_PLANS" ] && [ "$ALL_PLANS" != "[]" ]; then
                  # Found an unused plan in the subscription
                  EXISTING_PLAN_NAME=$(echo $ALL_PLANS | jq -r '.[0].name')
                  EXISTING_PLAN_LOCATION=$(echo $ALL_PLANS | jq -r '.[0].location')
                  
                  echo "Found unused App Service Plan '$EXISTING_PLAN_NAME' in $EXISTING_PLAN_LOCATION"
                  echo "WARNING: This plan belongs to a different project but will be used to avoid throttling."
                  
                  # Update location to match the found plan's location
                  LOCATION=$EXISTING_PLAN_LOCATION
                  APP_PLAN_NAME=$EXISTING_PLAN_NAME
                  
                  echo "AZURE_LOCATION=$LOCATION" >> $GITHUB_ENV
                  echo "APP_PLAN_NAME=$APP_PLAN_NAME" >> $GITHUB_ENV
                  echo "APP_SKU=$SKU" >> $GITHUB_ENV
                  
                  echo "Will create web app in this alternative location to avoid throttling."
                else
                  echo "ERROR: All attempts to create or find App Service Plan failed."
                  echo "Please manually create an App Service Plan named 'renopilot-plan-australiaeast' in the Azure portal"
                  echo "or request a quota increase by opening a support ticket with Azure."
                  echo "You can also try again later when throttling limits have reset."
                  exit 1
                fi
              else
                # Store App Service Plan name and SKU for later steps
                echo "APP_PLAN_NAME=$APP_PLAN_NAME" >> $GITHUB_ENV
                echo "APP_SKU=$SKU" >> $GITHUB_ENV
              fi
            fi
          fi

    - name: Create Web App and Configure
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          # Create Web App with region-specific name
          WEBAPP_NAME="renopilot-webapp-$LOCATION"
          
          # Check if Web App already exists
          if az webapp show --name $WEBAPP_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Web App '$WEBAPP_NAME' already exists. Skipping creation."
            echo "WEBAPP_NAME=$WEBAPP_NAME" >> $GITHUB_ENV
          else
            echo "Creating Web App '$WEBAPP_NAME'..."
            
            # Add retry logic with exponential backoff
            MAX_RETRIES=4
            RETRY_DELAY=30
            SUCCESS=false
            
            for ((attempt=1; attempt<=MAX_RETRIES; attempt++)); do
              echo "Attempt $attempt of $MAX_RETRIES to create Web App..."
              
              # Capture detailed error output
              if ERROR_OUTPUT=$(az webapp create \
                --resource-group RenoPilotWebAppRG \
                --plan ${{ env.APP_PLAN_NAME }} \
                --name $WEBAPP_NAME \
                --deployment-container-image-name nginx \
                --runtime "DOCKER|nginx" 2>&1); then
                
                echo "Web App created successfully!"
                echo "WEBAPP_NAME=$WEBAPP_NAME" >> $GITHUB_ENV
                SUCCESS=true
                break
              else
                echo "Failed to create Web App."
                echo "Error details:"
                echo "$ERROR_OUTPUT"
                
                if [[ "$ERROR_OUTPUT" == *"throttled"* ]]; then
                  # Handle throttling with exponential backoff
                  RETRY_DELAY=$((RETRY_DELAY * 2))
                  echo "Throttling detected. Increasing delay to $RETRY_DELAY seconds."
                fi
                
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "Waiting for $RETRY_DELAY seconds before next attempt..."
                  sleep $RETRY_DELAY
                fi
              fi
            done
            
            # If all attempts failed
            if [ "$SUCCESS" != "true" ]; then
              echo "WARNING: Failed to create Web App after $MAX_RETRIES attempts."
              
              # Try with a modified name as a fallback
              FALLBACK_NAME="${WEBAPP_NAME}-${RANDOM}"
              echo "Trying with fallback name: $FALLBACK_NAME"
              
              if az webapp create \
                --resource-group RenoPilotWebAppRG \
                --plan ${{ env.APP_PLAN_NAME }} \
                --name $FALLBACK_NAME \
                --deployment-container-image-name nginx \
                --runtime "DOCKER|nginx" &>/dev/null; then
                
                echo "Web App created with fallback name: $FALLBACK_NAME"
                WEBAPP_NAME=$FALLBACK_NAME
                echo "WEBAPP_NAME=$WEBAPP_NAME" >> $GITHUB_ENV
                SUCCESS=true
              else
                echo "ERROR: All attempts to create Web App failed."
                echo "Please check your Azure subscription and try again later."
                exit 1
              fi
            fi
            
            # Add delay to ensure webapp is created
            sleep 15
            
            # Configure environment variables with retry logic
            echo "Configuring environment variables for web app..."
            CONFIG_RETRIES=3
            for ((i=1; i<=CONFIG_RETRIES; i++)); do
              if az webapp config appsettings set \
                --resource-group RenoPilotWebAppRG \
                --name $WEBAPP_NAME \
                --settings \
                DOCKER_ENV=true \
                DB_SERVER=shiny.database.windows.net \
                DB_NAME=Shiny \
                DB_USER=shiny \
                DB_DRIVER="ODBC Driver 18 for SQL Server" \
                DB_PORT=1433 \
                WEBSITES_PORT=3838 \
                DB_PASSWORD="${{ secrets.DB_PASSWORD }}" &>/dev/null; then
                
                echo "Environment variables configured successfully!"
                break
              else
                echo "Failed to configure environment variables on attempt $i of $CONFIG_RETRIES"
                
                if [ $i -lt $CONFIG_RETRIES ]; then
                  echo "Waiting before retry..."
                  sleep 30
                else
                  echo "WARNING: Could not configure all environment variables."
                  echo "You may need to set them manually in the Azure portal."
                fi
              fi
            done
          fi

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      id: deploy
      with:
        app-name: ${{ env.WEBAPP_NAME }}
        images: ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }}
        slot-name: 'production'
        
    - name: Verify Deployment Success
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Verify deployment status
          echo "Verifying deployment status..."
          DEPLOYMENT_STATUS=$(az webapp deployment container show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query properties.status -o tsv 2>/dev/null || echo "Unknown")
          
          if [[ "$DEPLOYMENT_STATUS" == "Success" ]]; then
            echo "Deployment completed successfully!"
          else
            echo "Checking container readiness..."
            # Wait for up to 5 minutes for the container to become ready
            for i in {1..10}; do
              CONTAINER_STATUS=$(az webapp show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query state -o tsv 2>/dev/null || echo "Unknown")
              if [[ "$CONTAINER_STATUS" == "Running" ]]; then
                echo "Container is now running!"
                break
              fi
              echo "Container status: $CONTAINER_STATUS. Waiting 30 seconds..."
              sleep 30
            done
          fi
          
          # Display the web app URL with proper protocol
          WEBAPP_URL=$(az webapp show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query "defaultHostName" -o tsv)
          echo "Web app deployed at: https://$WEBAPP_URL"
          echo "Shiny app should be accessible at: https://$WEBAPP_URL"
          
          # Add a message to make the URL clickable in GitHub Actions log
          echo "::notice::Web app deployed at https://$WEBAPP_URL"

    - name: Configure Container Settings
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Configure container settings after deployment with retry logic
          echo "Configuring container settings after deployment..."
          
          MAX_RETRIES=3
          SUCCESS=false
          
          for ((i=1; i<=MAX_RETRIES; i++)); do
            echo "Attempt $i of $MAX_RETRIES to configure container settings..."
            
            if az webapp config container set \
              --name ${{ env.WEBAPP_NAME }} \
              --resource-group RenoPilotWebAppRG \
              --docker-custom-image-name ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }} \
              --docker-registry-server-url https://${{ env.ACR_LOGIN_SERVER }} \
              --docker-registry-server-user ${{ env.ACR_USERNAME }} \
              --docker-registry-server-password ${{ env.ACR_PASSWORD }} \
              --enable-app-service-storage false &>/dev/null; then
              
              echo "Container settings configured successfully!"
              SUCCESS=true
              break
            else
              echo "Failed to configure container settings on attempt $i"
              
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting before retry..."
                sleep 30
              fi
            fi
          done
          
          if [ "$SUCCESS" != "true" ]; then
            echo "WARNING: Could not configure all container settings properly."
            echo "The deployment might be affected. Consider checking the web app in Azure portal."
          fi
          
          # Explicitly set port mapping with retry logic
          echo "Setting port mapping to 3838..."
          for ((i=1; i<=MAX_RETRIES; i++)); do
            if az webapp config appsettings set \
              --resource-group RenoPilotWebAppRG \
              --name ${{ env.WEBAPP_NAME }} \
              --settings \
              WEBSITES_PORT=3838 &>/dev/null; then
              
              echo "Port mapping set successfully!"
              break
            else
              echo "Failed to set port mapping on attempt $i"
              
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting before retry..."
                sleep 30
              else
                echo "WARNING: Could not set port mapping."
              fi
            fi
          done
          
          # Restart web app with retry logic
          echo "Restarting web app to apply configuration..."
          for ((i=1; i<=MAX_RETRIES; i++)); do
            if az webapp restart --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
              echo "Web app restarted successfully!"
              break
            else
              echo "Failed to restart web app on attempt $i"
              
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Waiting before retry..."
                sleep 30
              else
                echo "WARNING: Could not restart the web app."
                echo "You may need to restart it manually in the Azure portal."
              fi
            fi
          done
          
          # Display the web app URL
          WEBAPP_URL=$(az webapp show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query "defaultHostName" -o tsv)
          echo "Web app deployed successfully at: https://$WEBAPP_URL"
          echo "Shiny app should be accessible at: https://$WEBAPP_URL"

    - name: Configure Network Security Rules
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Create rule collections for the region-specific firewalls
          echo "Creating firewall rule collections..."
          
          # Check if SQL traffic rule collection already exists
          if ! az network firewall network-rule collection show --name sqltraffic --firewall-name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            az network firewall network-rule create \
              --collection-name sqltraffic \
              --name SQLRule \
              --destination-ports 1433 \
              --firewall-name ${{ env.PRIVATE_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses 10.1.1.0/24 \
              --destination-addresses "*" \
              --action Allow \
              --priority 100 || echo "SQL rule creation failed, but continuing"
          else
            echo "SQL traffic rule collection already exists."
          fi
          
          # Check if Docker registry rule collection already exists
          if ! az network firewall network-rule collection show --name dockertraffic --firewall-name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Creating Docker registry rule collection..."
            az network firewall network-rule create \
              --collection-name dockertraffic \
              --name DockerRule \
              --destination-ports 5000 \
              --firewall-name ${{ env.PRIVATE_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses 10.1.1.0/24 \
              --destination-addresses 10.1.2.0/24 \
              --action Allow \
              --priority 200 || echo "Docker rule creation failed, but continuing"
          else
            echo "Docker registry rule collection already exists."
          fi
          
          # Check if HTTP rule collection already exists
          if ! az network firewall network-rule collection show --name webtraffic --firewall-name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Creating HTTP rule collection..."
            az network firewall network-rule create \
              --collection-name webtraffic \
              --name HTTPRule \
              --destination-ports 80 \
              --firewall-name ${{ env.PUBLIC_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses "*" \
              --destination-addresses 10.1.1.0/24 \
              --action Allow \
              --priority 300 || echo "HTTP rule creation failed, but continuing"
          else
            echo "HTTP rule collection already exists."
          fi
          
          # Check if Shiny rule collection already exists
          if ! az network firewall network-rule collection show --name shinytraffic --firewall-name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Creating Shiny rule collection..."
            az network firewall network-rule create \
              --collection-name shinytraffic \
              --name ShinyRule \
              --destination-ports 3838 \
              --firewall-name ${{ env.PUBLIC_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses "*" \
              --destination-addresses 10.1.1.0/24 \
              --action Allow \
              --priority 400 || echo "Shiny rule creation failed, but continuing"
          else
            echo "Shiny rule collection already exists."
          fi
          
          # Configure Azure SQL Server firewall rules
          echo "Configuring Azure SQL Server firewall rules..."
          
          # First check if SQL server exists
          if az sql server show --name shiny --resource-group RenoPilotWebAppRG &>/dev/null; then
            SUBNET_ADDRESS_PREFIX=$(az network vnet subnet show --resource-group RenoPilotWebAppRG --vnet-name ${{ env.VNET_NAME }} --name ${{ env.PUBLIC_SUBNET_NAME }} --query addressPrefix -o tsv)
            
            # Only try to create the firewall rule if the subnet was found
            if [ -n "$SUBNET_ADDRESS_PREFIX" ]; then
              echo "Found subnet prefix: $SUBNET_ADDRESS_PREFIX"
              # Check if firewall rule already exists
              if az sql server firewall-rule show --name "AllowWebAppSubnet" --server shiny --resource-group RenoPilotWebAppRG &>/dev/null; then
                echo "SQL firewall rule 'AllowWebAppSubnet' already exists."
              else
                echo "Creating SQL firewall rule 'AllowWebAppSubnet'..."
                az sql server firewall-rule create \
                  --resource-group RenoPilotWebAppRG \
                  --server shiny \
                  --name "AllowWebAppSubnet" \
                  --start-ip-address ${SUBNET_ADDRESS_PREFIX%/*} \
                  --end-ip-address 255.255.255.255 || echo "SQL server firewall rule creation failed, but continuing"
              fi
            else
              echo "Warning: Could not find subnet prefix. Skipping SQL firewall rule creation."
            fi
          else
            echo "SQL server 'shiny' not found. Skipping firewall rule creation."
          fi